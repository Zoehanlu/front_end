<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    // 原型 prototype
    // 1，定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。
    //          通过该构造函数产生的对象，可以继承改原型的对象和方法。原型也是对象
    // 2，利用原型的特点和概念，可以提取共有属性
    // 3，对象如何查看原型 --> 隐式属性 __proto__
    // 4，对象如何查看对象的构造函数 --> constructor
    // 原型链
    // 1,  绝大多数对象的最终都会继承自 Object.prototype 特例：Object.create(null)
    // 2,  Object.create(原型)
    var obj = {name: 'sunny'};
    var obj1 = Object.create(obj);
    // a.sayName() sayName里面的this指向谁，谁调用的这个方法，this就是指向谁
    Person.prototype = {
        name: 'a',
        sayName: function () {
            console.log(this.name)
        }
    }
    function Person() {
        this.name = 'b'
    }
    var person = new Person();    // b
   /* Person.prototype.name = "sunny"
    function Person() {
        // var this = {
        //     __proto__: Person.prototype
        // }
    }
    Person.prototype = {    // 1
        name: "cherry"
    }
    var person = new Person();   // name: cherry  当1放在下面是，name ： sunny
*/
    /*call/apply
    作用：改变this的指向
    区别: call: 需要把实参按照形参的个数传进去
          apply： 需要传一个arguments*/

    /*// 继承模式
    // 1，传统模式 --->  原型链：  过多继承了没用的属性
    // 例：
    function Grand() {}
    var grand  = new Grand();
    fathor.prototype = grand;
    function Father() {}
    var father = new Father();
    sun.prototype = father;
    function Son() {}
    var son = new Son();

    // 2，借用构造函数： (1) 不能继承借用构造函数的原型 （2）每次构造函数都要多走一个函数
    // 例：
    function Person(name, age, sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
    function Student(name, age, sex, grade) {
        Person.call(this, name, age, sex);  // Person.apply(this, [name, age, sex])
        this.grand = grade;
    }
    var student = new Student();

    // 3，共享原型：不能随便改动自己的原型
    // 例：
    Father.prototype.lastName = "li";
    function Father() {}
    function Son() {}
    Son.prototype = Father.prototype;
    // 4，圣杯模式
    // 例：
    function inherit(Target, Origin) {
        function F() {}
        F.prototype = Origin.prototype;
        Target.prototype = new F();
        Target.prototype.constructor = Target;  //
        Target.prototype.uber = Origin.prototype;   //超类
    }
    Father.prototype.lastName = "li";
    function Father() {}
    function Son() {}
    inherit(Son, Father);
    var son = new Son();
    var father = new Father();
    // son.__proto__ --> new F().__proto__ --> Father.prototype
*/

    命名空间：管理变量，防止污染全局，适用于模块化开发。
    对象的枚举：1，for in 2，hasOwnProperty  3，in 4，instanceof: 看A的原型链上有没有B的原型



</script>
</body>
</html>